st$Population[st$Area %in% out.val3] <- NA
st <- st[ complete.cases( st ), ]
st
sum(is.na(st))
st$Population[st$Population %in% out.val1] <- NA
st$Population[st$Income %in% out.val2] <- NA
st$Population[st$Area %in% out.val3] <- NA
head(st)
sum(is.na(st))
out.val1
st$Population[st$Population %in% out.val1] <- NA
st$Population[st$Income %in% out.val2] <- NA
st$Population[st$Area %in% out.val3] <- NA
is.na(st)
# 특이값, 이상치( outlier )
st <- data.frame( state.x77 )
summary( st$Income)
boxplot(st$Income)
boxplot.stats( st$Income )$out # boxplot.state : 통계자료 보여줌
out.val <- boxplot.stats( st$Income )$out
st$Income[ st$Income %in% out.val] <- NA
is.na(st)
sum(is.na(st))
st <- data.frame(state.x77)
#(2) 특이값이 존재하는 경우 이상치를 NA로 대체하여 저장하시오.
out.val1 <- boxplot.stats( st$Population )$out
out.val2 <- boxplot.stats( st$Income )$out
out.val3 <- boxplot.stats( st$Area )$out
st$Population[st$Population %in% out.val1] <- NA
st$Income[st$Income %in% out.val2] <- NA
st$Area[st$Area %in% out.val3] <- NA
is.na(st)
sum(is.na(st))
st <- st[ complete.cases( st ), ]
head(st)
sum(is.na(st))
sum(is.na(st))
st$Population[st$Population %in% out.val1] <- NA
st$Income[st$Income %in% out.val2] <- NA
st$Area[st$Area %in% out.val3] <- NA
sum(is.na(st))
st <- data.frame(state.x77)
#(2) 특이값이 존재하는 경우 이상치를 NA로 대체하여 저장하시오.
out.val1 <- boxplot.stats( st$Population )$out
out.val2 <- boxplot.stats( st$Income )$out
out.val3 <- boxplot.stats( st$Area )$out
st$Population[st$Population %in% out.val1] <- NA
st$Income[st$Income %in% out.val2] <- NA
st$Area[st$Area %in% out.val3] <- NA
sum(is.na(st))
head(st)
#(3) st에서 NA가 존재하는 행들을 제거하여 st2에 저장하시오.
st2 <- st[ !complete.cases(st), ]
is.na(st2)
sum(is.na(st2))
#(3) st에서 NA가 존재하는 행들을 제거하여 st2에 저장하시오.
st2 <- st[ complete.cases(st), ]
sum(is.na(st2))
AQ <- data.frame(airquality)
AQ
source('D:/workR/Leeyunji_20191205.R', encoding = 'UTF-8')
source('D:/workR/20191204.R', encoding = 'UTF-8')
install.packages("descr")
#(2) AQ에서 열별로 NA의 개수를 출력하시오.
for (i in 1:length(AQ)){
cat(colnames,"\t",
sum(is.na(AQ)), "\n")
}
#(2) AQ에서 열별로 NA의 개수를 출력하시오.
for (i in 1:length(AQ)){
cat(colnames(AQ)[i],"\t",
sum(is.na(AQ)), "\n")
}
AQ
sum(is.na(AQ))
head(AQ)
#(2) AQ에서 열별로 NA의 개수를 출력하시오.
for (i in 1:ncol(AQ)){
AQ.na <- is.na(AQ[,i])
cat(colnames(AQ)[i],
"\t", sum(AQ.na), "\n")
}
#(3) AQ에서 행별로 NA의 개수를 출력하시오.
for (i in 1:nrows(AQ)){
AQr.na <- is.na(AQ[i,])
cat(rownames(AQ)[i],
"\t", sum(AQr.na), "\n")
}
#(3) AQ에서 행별로 NA의 개수를 출력하시오.
for (i in 1:nrow(AQ)){
AQr.na <- is.na(AQ[i,])
cat(rownames(AQ)[i],
"\t", sum(AQr.na), "\n")
}
#(3) AQ에서 행별로 NA의 개수를 출력하시오.
dim(AQ)
AQ[ !complete.cases(AQ),]
AQ[ complete.cases(AQ),]
sum(is.na(AQ[ complete.cases(AQ),]))
AQ[ complete.cases(AQ),]
#(5) AQ에서 NA를 NA가 속한 열의 평균값으로 치환하여 AQ2로 저장하고, AQ2의 내용을 출력하시오.
AQ[is.na(AQ)] <-
# 열의 평균
colMeans(AQ)
help("colMeans")
#(5) AQ에서 NA를 NA가 속한 열의 평균값으로 치환하여 AQ2로 저장하고, AQ2의 내용을 출력하시오.
AQ[is.na(AQ)] <-
# 열의 평균
colMeans(AQ)
# 열의 평균
colMeans(AQ)
# 열의 평균
colMeans(AQ$Wind)
traffic <- read.csv("D:/workR/Report.csv")
head(traffic)
traffic <- traffic[8:82,2:4]
traffic
traffic <- subset( traffic, traffic$기준년도 == '발생건수')
traffic
str(traffic)
traffic <- traffic[,-2]
traffic
str(traffic)
st <- as.character(traffic$시군구)
class(st)
cnt <- as.numeric( as.character(traffic$X2018) )
class(cnt)
cnt
gct <- geocode( enc2utf8(st) )
head(gct)
seoul_t <- data.frame( name = st, lon = gct$lon, lat = gct$lat )
seoul_t
cen.st <- c( mean( seoul_t$lon ), mean( seoul_t$lat) );         cen.st
# 마커 그리기
map_st <- get_googlemap( center = cen.st,
maptype ="roadmap",
marker = seoul_t[,-1],
zoom = 11 )
# install.packages("Rtsne")
# library(Rtsne)
library(ggplot2)
library(Rtsne)
install.packages("Rtsne")
install.packages( c("rgl","car" ) )
library( rgl )
library( car )
library( mgcv )
library(ggmap)
register_google( key = 'AIzaSyDy5TVxSMCwjSz-3HjwO6bZDdQxt6klZ84' )
# 마커 그리기
map_st <- get_googlemap( center = cen.st,
maptype ="roadmap",
marker = seoul_t[,-1],
zoom = 11 )
cen.st <- c( mean( seoul_t$lon ), mean( seoul_t$lat) );         cen.st
seoul_t <- data.frame( name = st, lon = gct$lon, lat = gct$lat )
cnt
gct <- geocode( enc2utf8(st) )
head(gct)
seoul_t <- data.frame( name = st, lon = gct$lon, lat = gct$lat )
seoul_t
cen.st <- c( mean( seoul_t$lon ), mean( seoul_t$lat) );         cen.st
# 마커 그리기
map_st <- get_googlemap( center = cen.st,
maptype ="roadmap",
marker = seoul_t[,-1],
zoom = 11 )
ggmap(map_st)
# 원으로 그리기
map_st <- get_googlemap( center = cen.st, maptype ="roadmap")
#ggmap(map_st)
stmap <- ggmap(map_st)
stmap +
geom_point( data = traffic,
aes( x = seoul_t$lon, y = seoul_t$lat, size = cnt),
alpha = 0.5, col = "blue")+
scale_size_continuous( range = c(3,14))
jtraffic <- read.csv("D:/workR/Report.csv")
head(traffic)
jtraffic <- subset( jtraffic, jtraffic$시도 == '제주')
jtraffic <- read.csv("D:/workR/Report.csv")
head(traffic)
head(jtraffic)
jtraffic <- subset( jtraffic, jtraffic$시도 == '제주')
jtraffic <- traffic[4:nrow(jtraffic),]
jtraffic <- subset( jtraffic, jtraffic$기준년도 == '발생건수')
jtraffic <- jtraffic[,c(1,2,4)]
jtraffic
jtraffic <- read.csv("D:/workR/Report.csv")
head(jtraffic)
jtraffic <- subset( jtraffic, jtraffic$시도 == '제주')
jtraffic
jtraffic <- traffic[4:nrow(jtraffic),]
jtraffic
jtraffic <- read.csv("D:/workR/Report.csv")
head(jtraffic)
jtraffic <- subset( jtraffic, jtraffic$시도 == '제주')
jtraffic
jtraffic <- jtraffic[4:nrow(jtraffic),]
jtraffic
jtraffic <- subset( jtraffic, jtraffic$기준년도 == '발생건수')
jtraffic <- jtraffic[,c(1,2,4)]
jtraffic
str(traffic)
city <- as.character( traffic$시군구 )
class(city)
jcnt <- as.numeric( as.character(traffic$X2018) )
jcnt
jgc <- geocode( city ); jgc
jeju <- data.frame( name = city, lot = jgc$lon, lat = jgc$lat )
jeju
jtraffic <- read.csv("D:/workR/Report.csv")
head(jtraffic)
jtraffic <- subset( jtraffic, jtraffic$시도 == '제주')
jtraffic
jtraffic <- jtraffic[4:nrow(jtraffic),]
jtraffic
jtraffic <- subset( jtraffic, jtraffic$기준년도 == '발생건수')
jtraffic <- jtraffic[,c(1,2,4)]
jtraffic
str(jtraffic)
city <- as.character( jtraffic$시군구 )
class(city)
jcnt <- as.numeric( as.character(jtraffic$X2018) )
jcnt
jgc <- geocode( city ); jgc
jeju <- data.frame( name = city, lot = jgc$lon, lat = jgc$lat )
jeju
cen.j <- c( mean( jgc$lon ), mean(jgc$lat) )
cen.j
#마커 그리기
jeju_map <- get_googlemap( center = cen.j, mark = jeju[,-1],
maptype = "roadmap")
ggmap(jeju_map)
#원 그리기
jeju_map <- get_googlemap( center = cen.j, maptype = "roadmap")
jj <- ggmap(jeju_map)
jj +
geom_point( data = jeju,
aes( x = jeju$lot, y = jeju$lat, size = jcnt),
alpha = 0.5, col = "red" ) +
scale_size_continuous( range = c(8,14))
stmap +
geom_point( data = traffic,
aes( x = seoul_t$lon, y = seoul_t$lat, size = cnt),
alpha = 0.5, col = "blue")+
scale_size_continuous( range = c(3,14))
# 원으로 그리기
map_st <- get_googlemap( center = cen.st, maptype ="roadmap", size = c(640,640))
#ggmap(map_st)
stmap <- ggmap(map_st)
stmap +
geom_point( data = traffic,
aes( x = seoul_t$lon, y = seoul_t$lat, size = cnt),
alpha = 0.5, col = "blue")+
scale_size_continuous( range = c(3,14))
# 원으로 그리기
map_st <- get_googlemap( center = cen.st, maptype ="roadmap",
size = c(640,640), zoom = 11 )
#ggmap(map_st)
stmap <- ggmap(map_st)
stmap +
geom_point( data = traffic,
aes( x = seoul_t$lon, y = seoul_t$lat, size = cnt),
alpha = 0.5, col = "blue")+
scale_size_continuous( range = c(3,14))
stmap +
geom_point( data = traffic,
aes( x = seoul_t$lon, y = seoul_t$lat, size = cnt),
alpha = 0.5, col = "blue")+
scale_size_continuous( range = c(3,16))
stsne <- Rtsne( state, dim = 2, perplexity = 10)
# 이름 : 이윤지
# 작성일 : 2019. 12. 10
# 제출일 : 2019. 12. 11
#
#
#
# 문1) R에서 제공하는 state.x77 데이터셋을 차원 축소하여 2차원 산점도와 3차원 산점도를 작성하시오.
# (state.x77은 매트릭스 타입이기 때문에 데이터프레임으로 변환하여 실습한다.)
state <- data.frame( state.x77 )
str(state)
du <- which( duplicated( state ))
du # 중복데이터 없음
stsne <- Rtsne( state, dim = 2, perplexity = 10)
stsne
df.stsne <- data.frame(stsne$Y)
head(df.stsne)
ggplot( df.stsne, aes(x = X1, y = X2) ) +
geom_point( size = 3)
ggplot( df.stsne, aes(x = X1, y = X2) ) +
geom_point( size = 3, col = "blue")
ggplot( df.stsne, aes(x = X1, y = X2) ) +
geom_point( size = 3, col = "skyblue")
ggplot( df.stsne, aes(x = X1, y = X2) ) +
geom_point( size = 3, col = "yellowgreen")
ggplot( df.stsne, aes(x = X1, y = X2) ) +
geom_point( size = 3, col = "violet")
stsne3d <- Rtsne( state, dim = 3, perplexity = 10)
stsne3d
df.stsne3d <- data.frame( stsne3d$Y )
head( df.stsne3d )
scatter3d( x = df.stsne3d$X1, y = df.stsne3d$X2, z = df.stsne3d$X3)
scatter3d( x = df.stsne3d$X1, y = df.stsne3d$X2, z = df.stsne3d$X3, surface = FALSE )
seoul <- geocode( enc2utf8("서울특별시청"))
seoul
cen.seoul <- as.numeric( seoul )
cen.seoul
map <- get_googlemap( center = cen.seoul,
zoom = 18,
size = c(600,600),
maptype = "roadmap")
ggmap(map)
geomgang <- geocode( enc2utf8("금강산") )
geomgang
cen.geomgang <- as.numeric( geomgang )
map_g <- get_googlemap( center = cen.geomgang,
size = c(500, 500),
maptype = "hybrid",
zoom = 8 )
ggmap(map_g)
gangnam <- geocode( enc2utf8("강남역") )
gangnam
cen.gangnam <- as.numeric( gangnam )
cen.gangnam
mpg_gn <- get_googlemap( center = cen.gangnam,
size = c( 640, 640),
maptype = "roadmap",
zoom = 16)
ggmap(mpg_gn)
office.name <- c( '강남구청', '강동구청', '강서구청', '관악구청', '구로구청',
'금천구청', '동작구청', '서초구청', '송파구청', '양천구청', '영등포구청' )
gc <- geocode( enc2utf8( office.name ) )
gc
cen <- colMeans( as.matrix( gc ) )
map <- get_googlemap( center = cen,
size = c( 640, 640 ),
zoom = 11,
markers = gc,
maptype = 'roadmap' )
gmap <- ggmap( map )
gmap +
geom_text( data = data.frame( gc ),
aes( x = lon, y = lat ),
size = 3,
label = office.name )
office <- c("강서구청","구로구청","금천구청","동작구청",
"서초구청","강남구청","송파구청","강동구청")
gu <- geocode( office )
head(gu)
gu_office <- data.frame( name = office, lon = gu$lon, lat = gu$lat )
head(gu_office)
cen.gu <- c( mean( gu_office$lon ), mean( gu_office$lat ) )
cen.gu
gu_m <- get_googlemap( center = cen.gu,
maptype = "roadmap",
marker = gu_office[,-1],
zoom = 10)
gu_map <- ggmap(gu_m)
gu_map +
geom_text(data = gu_office,
aes( x = lon, y = lat ),
label = gu_office$name )
office <- c("강서구청","구로구청","금천구청","동작구청","관악구청",
"서초구청","강남구청","송파구청","강동구청","양청구청","영등포구청")
gu <- geocode( office )
head(gu)
gu_office <- data.frame( name = office, lon = gu$lon, lat = gu$lat )
head(gu_office)
cen.gu <- c( mean( gu_office$lon ), mean( gu_office$lat ) )
cen.gu
gu_m <- get_googlemap( center = cen.gu,
maptype = "roadmap",
marker = gu_office[,-1],
zoom = 10)
gu_map <- ggmap(gu_m)
gu_map +
geom_text(data = gu_office,
aes( x = lon, y = lat ),
label = gu_office$name )
gu_map +
geom_text(data = gu_office,
aes( x = lon, y = lat ),
label = office )
gu_m <- get_googlemap( center = cen.gu,
maptype = "roadmap",
marker = gu_office[,-1],
zoom = 11)
gu_map <- ggmap(gu_m)
gu_map +
geom_text(data = gu_office,
aes( x = lon, y = lat ),
label = office )
gw_map +
geom_text( data = city,
aes( x = lon, y = lat),
size = 5,
label = city$name) # label = gwang
gwang <- c("광주광역시","부산광역시","대전광역시",
"인천광역시","울산광역시","대구광역시")
gc <- geocode( gwang )
gc
city <- data.frame( name = gwang, lon = gc$lon, lat = gc$lat )
city
cen.city <- c( mean(city$lon), mean(city$lat))
map_gwang <- get_googlemap( center = cen.city, maptype = "roadmap",
zoom = 6, marker = city[,-1]) # marker = gc
gw_map <- ggmap(map_gwang)
gw_map +
geom_text( data = city,
aes( x = lon, y = lat),
size = 5,
label = city$name) # label = gwang
map_gwang <- get_googlemap( center = cen.city, maptype = "roadmap",
zoom = 7, marker = city[,-1]) # marker = gc
gw_map <- ggmap(map_gwang)
gw_map +
geom_text( data = city,
aes( x = lon, y = lat),
size = 5,
label = city$name) # label = gwang
gw_map +
geom_text( data = city,
aes( x = lon, y = lat),
size = 5,
label = gwang) # label = gwang
gw_map <- ggmap(map_gwang)
gw_map +
geom_text( data = city,
aes( x = lon, y = lat),
size = 5,
label = gwang) # label = gwang
#***** 필요시 설치 **
install.packages( "ggiraphExtra" ) # 단계구분도를 위한 Package
library( ggiraphExtra )
# 미국 주별 data set
dim( USArrests )
str( USArrests )
head( USArrests )
library( tibble )
# USArrests data set에 지역명 변수가 따로 없고, 대신 행이름이
# 지역명으로 되어있음
# tibble package의 rownames_to_column()를 이용해서 행 이름을
# state 변수로 바꿔서 data frame 생성
crime <- rownames_to_column( USArrests, var = "state" )
crime$state <- tolower( crime$state ) # 소문자로 수정
str( crime )
library( ggplot2 )
state_map <- map_data( "state" ) # ggplot2의 map_data()를 이용 data frame 생성
str( state_map )
# ggiraphExtra package에 포함된 단계구분도 작성 함수
ggChoropleth( data = crime,
aes( fill = Murder,
map_id = state ),
map = state_map,
interactive = F )
ggChoropleth( data = crime,
aes( fill = Murder,
map_id = state ),
map = state_map,
interactive = T ) # interactive를 T로 하면 지도위에
#***** 필요시 설치 **
install.packages( "stringi" )
install.packages( "devtools")
"
"
#***** 필요시 설치 **
devtools::install_github( "cardiomoon/kormaps2014" )
devtools::install_github( "cardiomoon/moonBook2" )
library( ggplot2 )
library( dplyr )
library( stringi )
library( ggiraphExtra )
library( kormaps2014 )
library( moonBook2 )
str( changeCode( areacode ) ) # kormaps2014 package의 changeCode()는
str( changeCode( kormap1 ) )  # encoding을 cp949로 변환
str( changeCode( korpop1 ) )
str( changeCode( kormap2 ) )
str( changeCode( korpop2 ) )
str( changeCode( kormap3 ) )
str( changeCode( korpop3 ) )
# 2015년도 시도별 인구분포 단계구분도
ggplot( korpop1, aes( map_id = code, fill = 총인구_명 ) ) +
geom_map( map = kormap1, colour = "black", size = 0.1 )+
expand_limits( x = kormap1$long, y = kormap2$lat ) +
scale_fill_gradientn( colours = c( 'white', 'orange', 'red' ) ) +
ggtitle( "2015년도 시도별 인구분포도" ) +
coord_map()
# ggChoropleth()이용 단계 구분도
ggChoropleth( korpop2, kormap2, fillvar = "남자_명" )
ggChoropleth( korpop3, kormap3, fillvar= "주택_계_호" )
# subarea 인수를 이용한 특정지역 표시 - Error
ggChoropleth( korpop3, kormap3, fillvar= "총인구_명",
subarea = c( "전라", "광주" ) )
# ggChoropleth()이용 interactive plot
ggChoropleth( korpop2, kormap2, fillvar="남자_명",
interactive = TRUE )
# Error
ggChoropleth( korpop3, kormap3, fillvar="남자_명",
interactive = TRUE,
subarea = c( "전라","광주" ),
tooltip = "행정구역별_읍면동" )
# 결핵신환 발생 데이터 tbc - 국가통계포털( kosis.kr ) 제공
dim( tbc )
str( changeCode( tbc ) )
tbc.sub <- tbc[ tbc$year %in% c( 2001, 2005, 2010, 2015 ), ]
# 년도별로 면 분활된 단계구분도
ggChoropleth( tbc.sub, kormap1, fillvar = "NewPts",
facetvar = "year",
tooltip = "name",
interactive = TRUE ) # 한글 깨짐
